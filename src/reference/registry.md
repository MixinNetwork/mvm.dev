# The principle and Use of Registry Contract

In the previous article about the deployment of the refund contract, we introduced how to deploy and use a complete contract in MVM. It was mentioned that the contract developer needs to make some modifications to the original contract, and now we further implemented the registry. sol, so that through the registry, the original contract can be directly deployed and used in MVM. 

The registry is the MVM's proxy contract. The original smart contract does not need to be modified, which can be executed directly through the registry after being deployed on Quorum.

## How to Use the Registry

1.  The contract developer deploys the EVM smart contract (the process is similar to the deployment of other contracts such as refund.sol), and after the deployment is completed, the contract address is obtained. 

2. When the user invokes the contract, he/she needs to use a payment link generated by the developer. The payment link can be generated via POST /payment. 

	Tip: There is no limit to the generation of this payment address, anyone who knows the contract address can generate one.

	Related Documentation：https://developers.mixin.one/zh-CN/docs/api/transfer/payment

  ```
  op := &encoding.Operation{
    Purpose: encoding.OperationPurposeGroupEvent, // fixed value 1
    Process: c.String("process"), // the client_id of the bot of the registry contract，TODO
    Extra:   extra, // the content of the contract execution
  }
  
  extra example：7c15d0d2faa1b63862880bed982bd3020e1f1a9a56688700000000000000000000000000bd6efc2e2cb99aef928433209c0a3be09a34f11400000000000000000000000000000000000000000000000000000000000007d0
  
  extra contains two parts:
  a. 0x7c15d0D2faA1b63862880Bed982bd3020e1f1A9A all lowercase after removing 0x is the address where the contract needs to be executed
  b. starting from 566887, it is the ABI value with detailed parameters via the addLiquidity(address,uint256) method,
     In the above example, c6d0c728-2624-429b-8e0d-d9d19b6592fa is the asset ID of BTC in the Mixin network 
     ABI code of amount 0.00002 will be introduced separately
     Code format reference：https://docs.soliditylang.org/en/v0.8.12/abi-spec.html
  ```

3. MVM receives this output, then parses the memo into Event 
4. MVM encodes the Event according to the format, and sends it to the registry contract 
5. The registry executes the `function mixin` and invokes the related contract  
6. After the execution is completed, relevant Event information is returned to MVM through `event MixinTransaction(bytes);`  
7. After MVM obtains the result, asset transfer will occur if needed, or skip instead if there is no need

Developers only need to get the code_id in step 2 and generate https://mixin.one/codes/:id, and the rest is the execution logic of MVM. For the generation of extra, and the encoding of Event, which will be specified in separate articles. 

## Function Mixin Implementation

`function mixin()` is the entry for MVM to call smart contracts, and it is also the only entry in the registry. All subsequent contract operations need to go through this function. 

When MVM calls the mixin function, raw will be parsed into relevant parameters, as follows: 

1. process (PID), uuid verifies whether the deployed process is the same as the called process
2. nonce, require nonce + 1 per call for EVM
3. asset id, the id of asset in the mixin
4. amount, the amounnt of assets that need to be manipulated
5. extra, contains some information about assets and contracts
6. timestamp, no verification currently, which is decided by the own situation of the contract whether to use it or not
7. user, Mixin user ID, or a multi-signature account, a corresponding Quorum account will be created, if the user does not exist
8. parse the extra value in 5, if the asset corresponding to Quorum does not exist, the asset will be created
9. signature verification
10. transfer corresponding asset to the Mixin user's corresponding MVM account
11. call the contract, after the execution is completed, destroy the assets in the MVM account 
12. return the call result (by calling `emit MixinTransaction` )

Specific code implementation,

```solidity
function mixin(bytes memory raw) public returns (bool) {
  require(raw.length >= 141, "event data too small");

  Event memory evt;
  uint256 offset = 0;

  uint128 id = raw.toUint128(offset);
  require(id == PID, "invalid process");
  offset = offset + 16;

  evt.nonce = raw.toUint64(offset);
  require(evt.nonce == INBOUND, "invalid nonce");
  INBOUND = INBOUND + 1;
  offset = offset + 8;

  (offset, id, evt.amount) = parseEventAsset(raw, offset);
  (offset, evt.extra, evt.timestamp) = parseEventExtra(raw, offset);
  (offset, evt.user) = parseEventUser(raw, offset);
  (evt.asset, evt.extra) = parseEventInput(id, evt.extra);

  offset = offset + 2;
  evt.sig = [raw.toUint256(offset), raw.toUint256(offset+32)];
  uint256[2] memory message = raw.slice(0, offset-2).concat(new bytes(2)).hashToPoint();
  require(evt.sig.verifySingle(GROUP, message), "invalid signature");

  offset = offset + 64;
  require(raw.length == offset, "malformed event encoding");

  emit MixinEvent(evt);
  MixinAsset(evt.asset).mint(evt.user, evt.amount);
  return MixinUser(evt.user).run(evt.asset, evt.amount, evt.extra);
}
```

## The Correspondence Between Users, Assets of Messenger and MVM Contracts  

Users and assets of Messenger need to correspond to the accounts and assets in MVM, and the corresponding methods can be obtained in the following three public maps:   

```solidity
mapping(address => bytes) public users;
mapping(address => uint128) public assets;
mapping(uint => address) public contracts;
```

## Open Source Code

registry.sol open source address: https://github.com/MixinNetwork/trusted-group/tree/master/mvm/quorum/contracts

## Conclusion

Compared with the refund.sol, contract developers need to do some compatible work (implementation of PID, `_work()`). And the registry assists in the realization work for the mixin users and Quorum accounts mapping, mixin assets and Quorum assets mapping, contract invocation, and the execution result returning. 

EVM contracts can also be directly migrated without modification. In the next chapter, we will introduce how to deploy a complete uniswap contract based on MVM. 
